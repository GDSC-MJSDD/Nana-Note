## CH12 - 함수

----
### 목차
>[1. 함수의 정의와 사용이유](#1-함수의-정의와-사용이유)<br>
>[2. 함수 리터럴](#2-함수-리터럴)<br>
>[3. 함수를 정의하는 4가지 방법(함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수-ES6)](#3-함수를-정의하는-4가지-방법--함수-선언문-함수-표현식-function-생성자-함수-화살표-함수-es6-)<br>
>[4. 함수 생성 시점과 함수 호이스팅](#4-함수-생성-시점과-함수-호이스팅)<br>
>[5. 함수 호출](#5-함수-호출)<br>
>[6. 참조에 의한 전달 & 외부 상태의 변경](#6-참조에-의한-전달--외부-상태의-변경)<br>
>[7. 다양한 함수 형태(즉시 실행, 재귀, 중첩, 콜백, 순수 & 비순수)](#7-다양한-함수-형태--즉시-실행-재귀-중첩-콜백-순수--비순수-)<br>

------

## 1. 함수의 정의와 사용이유

프로그래밍에서의 함수 정의<br>
<b>일련의 과정을 문(statement)으로 구현, 코드 블록으로 감싸서 하나의 실행 단위로 정의</b>

```
function add(x,y) {     // 함수 이름과 매개변수
    return x+y;         // 반환값
}                       // 여기까지가 함수 정의
add(2,5);               // 함수 호출
```

<b>함수는 함수 정의를 통해서 생성하고 함수 호출을 통해 실행하고 반환값을 반환한다.</b>

<br>
함수를 사용하는 이유<br>
<b>1. 함수는 몇번이든 호출 할 수 있어 코드의 재사용이라는 측면에서 매우 유용하다.</b><br>
<b>2. 함수는 객체 타입. 이름(식별자)을 붙일 수 있다 => 코드의 가독성이 좋아진다.</b><br>
<b>3. 코드의 중복을 억제+재사용성을 높이는 함수 => 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높인다.</b><br>
<br>


<br>


------


<br>

## 2. 함수 리터럴

JS의 함수는 객체 타입의 값이다. => 함수도 함수 리터럴로 생성하여 쓸 수가 있다.<br>
```
// 변수에 함수 리터럴을 할당
var f = function add(x,y) {     // 함수 이름을 생략할 수 있다(무명/익명함수)
    return x+y;
};
```
<b>리터럴은 값을 생성하기 위한 표기법이다.<br>
함수 리터럴도 평가되어 값을 생성 -> 이 값은 객체다 => 함수는 객체다.</b>

+) 일반객체 vs 함수 객체<br>
- 일반 객체는 호출 할 수 없지만, 함수는 호출할 수 있다.
- 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다.

<br>

---


## 3. 함수를 정의하는 4가지 방법(함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수-ES6)

### 함수 선언문
- <b>함수 선언문은 함수 이름을 생략할 수 없다.</b><br>
```
function add(x,y) {
    return x+y;
}
```
- <b>함수 선언문은 "표현식이 아닌 문"이다.<br>
+) 표현식이 아닌 문 vs 표현식인 문<br>
표현식인 문은 값으로 평가됨 -> 변수에 할당 가능<br>
표현식이 아닌 문은 값으로 평가 할 수 없음(값처럼 사용할 수 없다.) -> 변수에 할당하면 에러가 생김<br>

```
var add = function add(x,y) {
    return x+y;
};
```
이렇게 함수 선언문이 변수에 할당되는 것처럼 쓰일 때가 있다. 마치 함수 리터럴처럼.<br>
여기서 주의할 점 함수 선언문과 함수 리터럴을 어떻게 구분하지?<br>
- JS 엔진은 함수 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석
- 함수 리터럴이 값으로 평가되어야 하는 문맥이면 함수 리터럴 표현식으로 해석한다.<br>
=> 이 둘의 구분이 어려운데 내부 동작에서는 구분이 된다.
<br>
```
// 기명 함수 리터럴을 단독으로 사용 -> 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() { console.log('foo'); }
foo(); // foo

// 함수 리터럴을 피연산자로 사용 -> 함수 선언문이 아니라 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
( function bar() { console.log('bar'); });
bar(); // ReferenceError: bar is not defined
```
그래서 자바스크립트 엔진이 내부에서 인식하는 것은?
<br>
=> 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성 -> 거기에 함수 객체를 할당한다.
=> 함수는 함수 이름으로 호출되는 것이 아니라, 함수 객체를 가리키는 식별자로 호출한다.
<br>

### 함수 표현식

자바스크립트는 함수의 일급 객체다(값의 성질을 갖는 객체)<br>

### Function 생성자 함수

애매한 내용<br>
함수 선언문 or 함수 표현식으로 생성한 함수와 Function 생성자 함수로 생성한 함수가 동일하게 동작하지 않는다는 것에 집중.

### 화살표 함수
<br>
ES6 도입
<br>
항상 익명 함수로 정의<br>

```
const add = (x,y) => x+y;
console.log(add(2,5)); // 7
```

----



## 4. 함수 생성 시점과 함수 호이스팅

함수 선언문으로 정의한 함수 -> 이전에 호출 가능<br>
함수 표현식으로 정의한 함수 -> 함수 표현식 이전에 호출 불가능<br>
=> 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문
<br>

여기서 함수 호이스팅을 알 수 있다. -> 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 JS 고유의 특징
<br>

---

## 5. 함수 호출

- 매개변수와 인수
```
// 함수 선언문
function add(x,y) {
    return x+y;
}

// 함수 호출
// 인수 1과 2가 매개변수 x와 y에 순서대로 할당 -> 함수 몸체의 문들이 실행됨.
var result = add(1,2);
```
<br>
함수 호출은 표현식이다.
<br>-> return 키워드가 반환한 표현식의 평가 결과 = 반환값으로 평가된다.

반환문의 두 가지 역할<br>
1. 반환문은 함수의 실행을 중단, 함수 몸체를 빠져나간다.<br>
=> 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시.
2. 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환한다.

----


## 6. 참조에 의한 전달 & 외부 상태의 변경

원시 값 -> 값에 의한 전달<br>
객체 -> 참조에 의한 전달 방식으로 동작한다.<br>
매개 변수 -> 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따름.

---

## 7. 다양한 함수 형태(즉시 실행, 재귀, 중첩, 콜백, 순수 & 비순수)

### 즉시 실행 함수

함수 정의와 동시에 즉시 호출
```
// 익명 즉시 실행 함수
( function () {
    var a = 3;
    var b = 5;
    return a*b;
 }());
```
### 재귀 함수

함수가 자기 자신을 호출하는 것
```
function countdown(n) {
    if(n<0) return;
    console.log(n);
    countdown(n-1); // 재귀호출
    
    }
    countdown(10);
```

### 중첩함수(내부함수)

함수 내부에 정의 된 함수
```
function outer() {
    var x=1;
    
    // 중첩함수
    function inner() {
        var y=2;
        // 외부 함수의 변수를 참조할 수 있음.
        console.log(x+y); // 3
    }
    inner();
    }
    outer();
```

### 콜백함수

함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수<br>
매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수 = 고차 함수<br>
=> 고차함수는 콜백함수를 자신의 일부분으로 합성

```
// 익명 함수 리터럴을 콜백 함수로 고차 함수에 전달
// 익명 함수 리터럴 -> repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성
repeat(5, function (i) {
    if (i%2) console.log(i);
}); // 1 3
```

### 순수함수와 비순수 함수

순수 함수 -> 어떤 외부상태에 의존도 안하고 변경도 안하는, 부수효과가 없는 함수
<br>
외부 함수 -> 외부 상태에 의존하거나 외부 상태를 변경하는, 부수 효과가 있는 함수
<br>
```
var count = 0; // 현재 카운트를 나타내는 상태

// 순수 함수 increase는 동일한 인수가 전달되면 언제나 동일한 값을 반환
function increase(n) {
    return ++n;
}

// 순수 함수가 반환한 결과값을 변수에 재할당해서 상태 변경
count = increase(count);
console.log(count); // 1

count = increase(count);
console.log(count); // 2
```